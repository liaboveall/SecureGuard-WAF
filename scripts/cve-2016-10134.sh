#!/bin/bash

# =============================================================================
# CVE-2016-10134 (Zabbix SQL注入) WAF 防护部署脚本
# 自动化部署 ModSecurity WAF 来防护 Zabbix 应用
# =============================================================================

# 脚本目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# 加载配置和工具函数
source "$PROJECT_ROOT/utils/common.sh"
load_config "$PROJECT_ROOT/config/global.conf"

# CVE 特定配置
CVE_ID="CVE-2016-10134"
CVE_DESCRIPTION="Zabbix SQL注入漏洞"
WAF_RULE_ID_PREFIX="3000"

# 初始化环境
init_environment

# =============================================================================
# 主要功能函数
# =============================================================================

# 显示脚本信息
show_script_info() {
    print_header "CVE-2016-10134 WAF 防护部署"
    
    cat << EOF
${CYAN}漏洞信息:${NC}
  • CVE ID: $CVE_ID
  • 描述: $CVE_DESCRIPTION
  • 目标端口: $ZABBIX_HOST_PORT
  • WAF 端口: $WAF_HOST_PORT

${YELLOW}部署内容:${NC}
  • Zabbix 3.0.3 漏洞环境
  • ModSecurity WAF 防护层
  • 自定义 SQL 注入检测规则
  • 流量重定向配置

EOF
}

# 创建 Dockerfile 模板
create_dockerfile_template() {
    local template_file="$TEMPLATE_DIR/zabbix-waf-dockerfile"
    
    cat > "$template_file" << 'EOF'
# 文件: Dockerfile for Zabbix WAF Protection
FROM ubuntu:20.04

ENV DEBIAN_FRONTEND=noninteractive

# 安装必要的软件包
RUN apt-get update && \
    apt-get install -y apache2 libapache2-mod-security2 nano && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# 启用 Apache 模块
RUN a2enmod proxy \
    && a2enmod proxy_http \
    && a2enmod rewrite \
    && a2enmod headers \
    && a2enmod security2

# 复制配置文件
COPY custom_security2.conf /etc/apache2/mods-enabled/security2.conf
COPY apache-vhost.conf /etc/apache2/sites-available/000-default.conf

# 配置 ModSecurity
RUN cp /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf
COPY modsecurity.conf /etc/modsecurity/modsecurity.conf 

# 创建规则目录并复制规则
RUN mkdir -p /etc/modsecurity/rules.d
COPY custom-zabbix-rules.conf /etc/modsecurity/rules.d/custom-zabbix-rules.conf

# 设置 ModSecurity 数据目录权限
RUN mkdir -p /var/cache/modsecurity && chown www-data:www-data /var/cache/modsecurity

EXPOSE 80
CMD ["apache2ctl", "-D", "FOREGROUND"]
EOF

    log_success "Dockerfile 模板已创建: $template_file"
}

# 创建 Apache 虚拟主机配置
create_apache_vhost_config() {
    local config_file="$CONFIG_DIR/apache-vhost.conf"
    
    cat > "$config_file" << EOF
# Apache 虚拟主机配置 - Zabbix WAF
<VirtualHost *:80>
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html

    ErrorLog \${APACHE_LOG_DIR}/error.log
    CustomLog \${APACHE_LOG_DIR}/access.log combined

    ProxyRequests Off
    ProxyPreserveHost On
    # 代理到 Zabbix 应用容器
    ProxyPass / http://$ZABBIX_CONTAINER_NAME:80/
    ProxyPassReverse / http://$ZABBIX_CONTAINER_NAME:80/

    <IfModule security2_module>
        SecAuditLog /var/log/apache2/modsec_audit_vhost.log
    </IfModule>
</VirtualHost>
EOF

    log_success "Apache 虚拟主机配置已创建: $config_file"
}

# 创建 ModSecurity 主配置
create_modsecurity_config() {
    local config_file="$CONFIG_DIR/modsecurity.conf"
    
    cat > "$config_file" << EOF
# ModSecurity 主配置文件
SecRuleEngine $MODSEC_RULE_ENGINE

SecAuditEngine RelevantOnly
SecAuditLog $MODSEC_AUDIT_LOG
SecAuditLogParts ABIJDEFHZ

# 请求体设置
SecRequestBodyAccess On
SecRequestBodyLimit 13107200
SecRequestBodyNoFilesLimit 131072
SecRequestBodyInMemoryLimit 131072

# 响应体设置
SecResponseBodyAccess On
SecResponseBodyMimeType text/plain text/html text/xml application/json application/javascript
SecResponseBodyLimit 524288

# 其他设置
SecTmpDir /tmp/
SecDataDir /var/cache/modsecurity

SecDefaultAction "phase:2,deny,log,status:403"
EOF

    log_success "ModSecurity 主配置已创建: $config_file"
}

# 创建自定义 Zabbix 规则
create_custom_zabbix_rules() {
    local rules_file="$CONFIG_DIR/custom-zabbix-rules.conf"
    
    cat > "$rules_file" << EOF
# 自定义 Zabbix SQL 注入检测规则
# 针对 CVE-2016-10134 的防护规则

# 初始化 SQLi 异常得分变量
SecRule REQUEST_FILENAME "@endsWith /latest.php" \\
    "id:${WAF_RULE_ID_PREFIX}0,\\
    phase:1,\\
    pass,\\
    nolog,\\
    setvar:tx.my_sqli_score=0"

# 规则 1: 检测高危 SQL 函数调用模式
SecRule REQUEST_FILENAME "@endsWith /latest.php" \\
    "id:${WAF_RULE_ID_PREFIX}1,\\
    phase:2,\\
    pass,\\
    chain,\\
    msg:'高危 SQL 函数调用检测 (如 updatexml)',\\
    tag:'CUSTOM_SQLI/FUNCTION_DIRECT_CALL',\\
    severity:'CRITICAL',\\
    setvar:'tx.my_sqli_score=+10'"
  SecRule ARGS:toggle_ids "@rx (?i)\\b(updatexml|extractvalue|gtid_subset|benchmark|sleep|floor\\s*\\(\\s*rand\\s*\\()\\s*\\("

# 规则 2: 检测可疑 SQL 语法
SecRule REQUEST_FILENAME "@endsWith /latest.php" \\
    "id:${WAF_RULE_ID_PREFIX}2,\\
    phase:2,\\
    pass,\\
    chain,\\
    msg:'可疑 SQL 语法检测 (行注释或关键字)',\\
    tag:'CUSTOM_SQLI/SYNTAX_KEYWORD',\\
    severity:'WARNING',\\
    setvar:'tx.my_sqli_score=+5'"
  SecRule ARGS:toggle_ids "@rx (?i)(?:--|#|\\b(?:select|union|or|and|insert|delete)\\b)"

# 规则 3: 基于累计得分的拦截
SecRule REQUEST_FILENAME "@endsWith /latest.php" \\
    "id:${WAF_RULE_ID_PREFIX}3,\\
    phase:2,\\
    deny,\\
    chain,\\
    status:403,\\
    msg:'SQL 注入攻击检测 - 累计异常得分过高',\\
    tag:'CUSTOM_SQLI/SCORE_THRESHOLD',\\
    severity:'CRITICAL'"
  SecRule TX:my_sqli_score "@ge 10"

# 规则 4: 检测常见注入字符序列
SecRule REQUEST_FILENAME "@endsWith /latest.php" \\
    "id:${WAF_RULE_ID_PREFIX}4,\\
    phase:2,\\
    deny,\\
    status:403,\\
    msg:'SQL 注入字符序列检测',\\
    tag:'CUSTOM_SQLI/CHAR_SEQUENCE',\\
    severity:'HIGH'"
  SecRule ARGS:toggle_ids "@rx (?i)(['\\\"].*?['\\\"]|\\\\x[0-9a-f]{2}|\\\\[0-7]{1,3})"

# 规则 5: 防护绕过检测（块注释）
SecRule REQUEST_FILENAME "@endsWith /latest.php" \\
    "id:${WAF_RULE_ID_PREFIX}5,\\
    phase:2,\\
    deny,\\
    status:403,\\
    msg:'SQL 注入块注释绕过检测',\\
    tag:'CUSTOM_SQLI/BLOCK_COMMENT_BYPASS',\\
    severity:'HIGH'"
  SecRule ARGS:toggle_ids "@rx /\\*.*?\\*/"
EOF

    log_success "自定义 Zabbix 规则已创建: $rules_file"
}

# 创建 Docker Compose 配置
create_docker_compose() {
    local compose_file="$PROJECT_ROOT/docker-compose-zabbix.yml"
    
    cat > "$compose_file" << EOF
version: '3.8'

services:
  # Zabbix 漏洞应用
  $ZABBIX_CONTAINER_NAME:
    image: $ZABBIX_IMAGE
    container_name: $ZABBIX_CONTAINER_NAME
    restart: unless-stopped
    networks:
      - $DOCKER_NETWORK
    environment:
      - ZABBIX_SERVER_HOST=zabbix-server
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/zabbix/"]
      interval: 30s
      timeout: 10s
      retries: 5

  # ModSecurity WAF
  $WAF_CONTAINER_NAME:
    build:
      context: ./config
      dockerfile: ../templates/zabbix-waf-dockerfile
    container_name: $WAF_CONTAINER_NAME
    restart: unless-stopped
    ports:
      - "$WAF_HOST_PORT:80"
    networks:
      - $DOCKER_NETWORK
    volumes:
      - $LOG_DIR:/var/log/apache2
      - $LOG_DIR/modsecurity:/var/log/modsecurity
    depends_on:
      $ZABBIX_CONTAINER_NAME:
        condition: service_healthy
    environment:
      - APACHE_LOG_LEVEL=$APACHE_LOG_LEVEL

networks:
  $DOCKER_NETWORK:
    external: true
EOF

    log_success "Docker Compose 配置已创建: $compose_file"
}

# 创建部署脚本
create_deployment_script() {
    local deploy_script="$SCRIPT_DIR/deploy-zabbix-waf.sh"
    
    cat > "$deploy_script" << 'EOF'
#!/bin/bash

# Zabbix WAF 部署脚本
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

source "$PROJECT_ROOT/utils/common.sh"
load_config "$PROJECT_ROOT/config/global.conf"

init_environment

print_header "部署 Zabbix WAF 防护"

# 检查依赖
if ! check_dependencies; then
    exit 1
fi

if ! check_docker_status; then
    exit 1
fi

# 创建网络
create_docker_network

# 检查端口
if ! check_port "$WAF_HOST_PORT" "WAF"; then
    if ! ask_confirmation "端口 $WAF_HOST_PORT 被占用，是否继续?"; then
        exit 1
    fi
fi

# 启动服务
log_info "启动 Zabbix WAF 防护服务..."
docker-compose -f "$PROJECT_ROOT/docker-compose-zabbix.yml" up -d

# 等待服务启动
if wait_for_container "$ZABBIX_CONTAINER_NAME"; then
    wait_for_container "$WAF_CONTAINER_NAME"
fi

# 检查健康状态
sleep 10
check_container_health "$ZABBIX_CONTAINER_NAME"
check_container_health "$WAF_CONTAINER_NAME"

# 显示访问信息
cat << EOL

${GREEN}部署完成!${NC}

访问信息:
  • WAF 保护的 Zabbix: http://localhost:$WAF_HOST_PORT
  • 直接访问 Zabbix: http://localhost:$ZABBIX_HOST_PORT (如果暴露)

监控日志:
  • WAF 日志: $LOG_DIR/
  • ModSecurity 审计日志: $LOG_DIR/modsecurity/

测试命令:
  curl "http://localhost:$WAF_HOST_PORT/latest.php?toggle_ids[]=updatexml(1,concat(0x7e,version(),0x7e),1)"

EOL
EOF

    chmod +x "$deploy_script"
    log_success "部署脚本已创建: $deploy_script"
}

# 创建清理脚本
create_cleanup_script() {
    local cleanup_script="$SCRIPT_DIR/cleanup-zabbix-waf.sh"
    
    cat > "$cleanup_script" << 'EOF'
#!/bin/bash

# Zabbix WAF 清理脚本
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

source "$PROJECT_ROOT/utils/common.sh"
load_config "$PROJECT_ROOT/config/global.conf"

init_environment

print_header "清理 Zabbix WAF 环境"

if ask_confirmation "确定要清理 Zabbix WAF 环境吗? 这将删除所有相关容器和网络"; then
    log_info "停止并删除服务..."
    docker-compose -f "$PROJECT_ROOT/docker-compose-zabbix.yml" down -v
    
    log_info "删除相关容器..."
    remove_container "$ZABBIX_CONTAINER_NAME"
    remove_container "$WAF_CONTAINER_NAME"
    
    log_info "清理网络..."
    remove_docker_network
    
    if ask_confirmation "是否删除日志文件?"; then
        rm -rf "$LOG_DIR"/*
        log_info "日志文件已清理"
    fi
    
    log_success "清理完成"
else
    log_info "取消清理操作"
fi
EOF

    chmod +x "$cleanup_script"
    log_success "清理脚本已创建: $cleanup_script"
}

# 生成测试脚本
create_test_script() {
    local test_script="$SCRIPT_DIR/test-zabbix-waf.sh"
    
    cat > "$test_script" << 'EOF'
#!/bin/bash

# Zabbix WAF 测试脚本
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

source "$PROJECT_ROOT/utils/common.sh"
load_config "$PROJECT_ROOT/config/global.conf"

init_environment

print_header "Zabbix WAF 防护测试"

# 测试目标 URL
BASE_URL="http://localhost:$WAF_HOST_PORT"
TEST_ENDPOINT="$BASE_URL/latest.php"

# 测试用例
declare -A test_cases=(
    ["正常请求"]="$TEST_ENDPOINT?toggle_ids[]=1"
    ["SQL注入-updatexml"]="$TEST_ENDPOINT?toggle_ids[]=updatexml(1,concat(0x7e,version(),0x7e),1)"
    ["SQL注入-union"]="$TEST_ENDPOINT?toggle_ids[]=1' UNION SELECT version()--"
    ["SQL注入-块注释绕过"]="$TEST_ENDPOINT?toggle_ids[]=1'/**/UNION/**/SELECT/**/version()--"
    ["SQL注入-十六进制编码"]="$TEST_ENDPOINT?toggle_ids[]=1' AND 1=0x31--"
)

log_info "开始测试 WAF 防护效果..."
echo

# 执行测试
for test_name in "${!test_cases[@]}"; do
    url="${test_cases[$test_name]}"
    log_info "测试: $test_name"
    
    response=$(curl -s -o /dev/null -w "%{http_code}" "$url" 2>/dev/null)
    
    case $response in
        200)
            if [[ "$test_name" == "正常请求" ]]; then
                log_success "✓ 正常请求通过 (HTTP $response)"
            else
                log_error "✗ 攻击请求未被拦截 (HTTP $response)"
            fi
            ;;
        403)
            if [[ "$test_name" == "正常请求" ]]; then
                log_error "✗ 正常请求被误拦截 (HTTP $response)"
            else
                log_success "✓ 攻击请求已拦截 (HTTP $response)"
            fi
            ;;
        *)
            log_warning "? 未知响应状态 (HTTP $response)"
            ;;
    esac
    echo
done

# 检查日志
log_info "最近的 WAF 日志:"
if [[ -f "$LOG_DIR/modsecurity/modsec_audit.log" ]]; then
    tail -20 "$LOG_DIR/modsecurity/modsec_audit.log" | grep -E "(Message|timestamp)" || log_info "暂无相关日志"
else
    log_warning "WAF 审计日志文件不存在"
fi
EOF

    chmod +x "$test_script"
    log_success "测试脚本已创建: $test_script"
}

# =============================================================================
# 主执行流程
# =============================================================================

main() {
    show_script_info
    
    if ! ask_confirmation "是否继续创建 $CVE_ID WAF 防护配置?"; then
        log_info "操作已取消"
        exit 0
    fi
    
    # 检查依赖
    if ! check_dependencies; then
        exit 1
    fi
    
    if ! validate_config; then
        exit 1
    fi
    
    # 创建配置文件
    log_info "创建配置文件和模板..."
    show_progress 1 7 "创建 Dockerfile 模板"
    create_dockerfile_template
    
    show_progress 2 7 "创建 Apache 虚拟主机配置"
    create_apache_vhost_config
    
    show_progress 3 7 "创建 ModSecurity 配置"
    create_modsecurity_config
    
    show_progress 4 7 "创建自定义防护规则"
    create_custom_zabbix_rules
    
    show_progress 5 7 "创建 Docker Compose 配置"
    create_docker_compose
    
    show_progress 6 7 "创建部署和清理脚本"
    create_deployment_script
    create_cleanup_script
    
    show_progress 7 7 "创建测试脚本"
    create_test_script
    
    print_header "配置生成完成"
    
    cat << EOF
${GREEN}$CVE_ID WAF 防护配置已生成!${NC}

生成的文件:
  ${CYAN}配置文件:${NC}
    • $CONFIG_DIR/apache-vhost.conf
    • $CONFIG_DIR/modsecurity.conf
    • $CONFIG_DIR/custom-zabbix-rules.conf
    • docker-compose-zabbix.yml

  ${CYAN}脚本文件:${NC}
    • $SCRIPT_DIR/deploy-zabbix-waf.sh (部署)
    • $SCRIPT_DIR/cleanup-zabbix-waf.sh (清理)
    • $SCRIPT_DIR/test-zabbix-waf.sh (测试)

${YELLOW}下一步操作:${NC}
  1. 运行部署脚本: ./scripts/deploy-zabbix-waf.sh
  2. 测试防护效果: ./scripts/test-zabbix-waf.sh
  3. 查看日志: tail -f $LOG_DIR/modsecurity/modsec_audit.log

EOF

    if ask_confirmation "是否立即运行部署脚本?"; then
        "$SCRIPT_DIR/deploy-zabbix-waf.sh"
    fi
}

# 执行主函数
main "$@"
